<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>Lanchester Duel</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: #1b1b1b;
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 { margin: 10px; }
    #controls { margin-bottom: 10px; }
    #gameCanvas {
      border: 2px solid #eee;
      background: #111;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Lanchester Duel</h1>
  <div id="controls">
    <button id="readyBtn">Готово</button>
  </div>
  <canvas id="gameCanvas" width="1000" height="600"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const MAX_MOVE = 120;
    const MIN_FRACTION = 1/20;
    const UNIT_BASE = 100;
    const UNIT_SIZE = 30;

    let gamePhase = "placement";
    let currentPlayer = 1;
    let units = [];
    let selectedUnit = null;
    let initialValue = UNIT_BASE;

    document.getElementById("readyBtn").addEventListener("click", () => {
      if (gamePhase === "placement") {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        if (units.some(u=>u.player===1) && units.some(u=>u.player===2)) {
          gamePhase = "movementSetup";
          currentPlayer = 1;
        }
      } else if (gamePhase === "movementSetup") {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        if (units.every(u=>u.orderGiven)) {
          gamePhase = "battle";
          animateBattle();
        }
      } else if (gamePhase === "battle") {
        for (let u of units) { u.target=null; u.orderGiven=false; }
        gamePhase = "movementSetup";
        currentPlayer = 1;
      }
      draw();
    });

    canvas.addEventListener("click", (e) => {
      const {x,y} = getMouse(e);
      if (gamePhase === "placement") {
        addUnit(x,y,currentPlayer,initialValue);
        currentPlayer = currentPlayer===1?2:1;
      } else if (gamePhase === "movementSetup") {
        const clicked = getUnitAt(x,y);
        if (clicked && clicked.player===currentPlayer) {
          selectedUnit = clicked;
        } else if (selectedUnit) {
          const dx = x - selectedUnit.x;
          const dy = y - selectedUnit.y;
          const dist = Math.sqrt(dx*dx+dy*dy);
          const scale = dist>MAX_MOVE ? MAX_MOVE/dist : 1;
          selectedUnit.target = {
            x: selectedUnit.x + dx*scale,
            y: selectedUnit.y + dy*scale,
            dx: dx*scale,
            dy: dy*scale,
            angle: Math.atan2(dy,dx)
          };
          selectedUnit.orderGiven = true;
          selectedUnit = null;
        }
      }
      draw();
    });

    canvas.addEventListener("dblclick",(e)=>{
      const {x,y} = getMouse(e);
      const u = getUnitAt(x,y);
      if (u && u.value>=2*UNIT_BASE*MIN_FRACTION) {
        const half=Math.floor(u.value/2);
        u.value=half;
        addUnit(u.x+40,u.y,u.player,half);
      }
    });

    function getMouse(e){
      const rect=canvas.getBoundingClientRect();
      return {x:e.clientX-rect.left,y:e.clientY-rect.top};
    }

    function addUnit(x,y,player,value){
      units.push({x,y,player,value,target:null,orderGiven:false,alive:true});
    }
    function getUnitAt(x,y){
      return units.find(u =>
        x>u.x-getSize(u)/2 && x<u.x+getSize(u)/2 &&
        y>u.y-getSize(u)/2 && y<u.y+getSize(u)/2
      );
    }
    function getSize(u){ return UNIT_SIZE*Math.sqrt(u.value/UNIT_BASE); }
    function distance(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }

    function animateBattle(){
      let steps=30,step=0;
      const anim=setInterval(()=>{
        step++;
        for (let u of units){
          if (u.target){
            let nx=u.x+u.target.dx/steps;
            let ny=u.y+u.target.dy/steps;
            if (!collidesEnemy(u,nx,ny)) {
              u.x=nx; u.y=ny;
            }
          }
        }
        mergeOverlaps();
        draw(true);
        if (step>=steps){
          clearInterval(anim);
          executeBattle();
          draw(true);
        }
      },40);
    }

    function collidesEnemy(unit,nx,ny){
      for (let v of units){
        if (v!==unit && v.player!==unit.player){
          if (Math.hypot(nx-v.x,ny-v.y)<(getSize(unit)+getSize(v))/2){
            return true;
          }
        }
      }
      return false;
    }

    function executeBattle(){
      for (let u of units){ u.damage=0; }
      for (let u of units){
        const enemies=units.filter(v=>v.player!==u.player && distance(u,v)<MAX_MOVE);
        if (enemies.length>0){
          if (u.target){
            const perEnemy=u.value/enemies.length;
            for (let e of enemies){
              let angToE=Math.atan2(e.y-u.y,e.x-u.x);
              let diff=Math.abs(normalizeAngle(angToE-u.target.angle));
              if (diff<=Math.PI/2){
                e.damage+=perEnemy;
              }
            }
          } else {
            const perEnemy=(u.value/10)/enemies.length;
            for (let e of enemies){ e.damage+=perEnemy; }
          }
        }
      }

      for (let u of units){
        let newValue=Math.max(u.value-u.damage,0);
        u.targetValue=newValue;

        if (u.damage>u.value){
          // изчисляваме вектор на отстъпление
          let vec={x:0,y:0};
          for (let a of units.filter(v=>v.player!==u.player)){
            let dx=u.x-a.x,dy=u.y-a.y;
            let d=Math.hypot(dx,dy)||1;
            vec.x+=dx/d*a.damage; vec.y+=dy/d*a.damage;
          }
          let retreatAng=Math.atan2(vec.y,vec.x);
          if (u.target){
            let diff=Math.abs(normalizeAngle(retreatAng-u.target.angle));
            if (diff>Math.PI/2){
              u.target.angle=retreatAng;
              u.target.dx=Math.cos(retreatAng)*MAX_MOVE;
              u.target.dy=Math.sin(retreatAng)*MAX_MOVE;
              u.target.x=u.x+u.target.dx;
              u.target.y=u.y+u.target.dy;
            }
          } else {
            u.target={x:u.x+Math.cos(retreatAng)*50,
                      y:u.y+Math.sin(retreatAng)*50,
                      dx:Math.cos(retreatAng)*50,
                      dy:Math.sin(retreatAng)*50,
                      angle:retreatAng};
          }
        }
      }
      animateDamage();
    }

    function animateDamage(){
      let steps=300; // 10 пъти по-бавно
      let step=0;
      const anim=setInterval(()=>{
        step++;
        for (let u of units){
          if (u.targetValue!==undefined){
            u.value += (u.targetValue - u.value) / (steps - step + 1);
          }
        }
        draw(true);
        if (step>=steps){
          clearInterval(anim);
          for (let u of units){
            if (u.targetValue!==undefined){
              u.value=u.targetValue;
              delete u.targetValue;
            }
          }
          removeWeak();
          draw(true);
        }
      },40);
    }

    function normalizeAngle(a){
      while(a>Math.PI)a-=2*Math.PI;
      while(a<-Math.PI)a+=2*Math.PI;
      return a;
    }

    function removeWeak(){
      units=units.filter(u=>u.value>UNIT_BASE*MIN_FRACTION);
    }
    function mergeOverlaps(){
      for (let i=0;i<units.length;i++){
        for (let j=i+1;j<units.length;j++){
          let a=units[i],b=units[j];
          if (a.player===b.player && distance(a,b)<(getSize(a)+getSize(b))/3){
            a.value+=b.value;
            units.splice(j,1);
            j--;
          }
        }
      }
    }

    function draw(hideArrows=false){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for (let u of units){
        ctx.fillStyle=u.player===1?"blue":"red";
        const size=getSize(u);
        ctx.save();
        ctx.translate(u.x,u.y);
        ctx.fillRect(-size/2,-size/2,size,size);
        ctx.restore();
        ctx.fillStyle="white";
        ctx.font=`${10+u.value/20}px Arial`;
        ctx.fillText(Math.round(u.value),u.x-10,u.y-5);
        if (u.target && !hideArrows && gamePhase==="movementSetup" && u.player===currentPlayer){
          ctx.strokeStyle="yellow";
          ctx.beginPath();
          ctx.moveTo(u.x,u.y);
          ctx.lineTo(u.target.x,u.target.y);
          ctx.stroke();
        }
      }
    }

    draw();
  </script>
</body>
</html>
